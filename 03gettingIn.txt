# Getting In

_Know thyself - Ancient Greek maxim_

## A Quick Exercise

Write a function to compute factorial of a given number, _n_. 

A factorial is a product of all positive integers from 1 to a given number, _n_. For example, 5 factorial (written as 5!) is 5*4*3*2*1 = 120. If you were sitting next to someone who knew very little about programming, how would you begin to outline what you are trying to do? How would you outline the structure of your code?

Many beginning programmers write a [recursive](http://en.wikipedia.org/wiki/Recursion) solution to this coding challenge. That would work fine to compute 5! or 10! How well does it work for 100! or 1000!?

So, now what? If a recursive solution doesn't quite work, because of the computing time, how would you restructure your code?  Is there a way to compute the multiplication non-recursively from 1 to _n_? And how does that improve performance? Could you refactor your code further to take advantage of a technique called [__memoization__](http://en.wikipedia.org/wiki/Memoization)?

Did you enjoy trying to figure this problem out? Would you enjoy doing so with someone else next to you? Does the process of optimizing your code and make it compute faster appeal to you?

### New Exercise: Listen to Yourself

If you either 1) didn't have enough background to successfuly attempt writing a factorial function, or 2) enjoyed the exercise and want more, might we suggest the following resources?

If former - i.e. you need more basics - try this [Ruby in 100 Minutes Tutorial](http://tutorials.jumpstartlab.com/projects/ruby_in_100_minutes.html) by [JumpstartLab](http://jumpstartlab.com). If latter - i.e. Factorials exercise was a breeze - try your hand at some more challenging algorithms using language of your choice by browsing [Project Euler](http://projecteuler.net/) exercises.

As you try these exercises & tutorials, rather than focusing on the content per se, observe your feelings and thoughts during the learning process. How does it feel?  Does the prospect of seeing bunch of new keywords annoy you? frustrate you? scare you? or excite you?  As the volume of information and difficulty of concepts rise, how do you react? Do you see yourself taking a break and hesitate to return to the material? Or does the exposure to the basic concepts and keywords set you about searching for more detail on wikipedia or Stack Overflow?  

Take a moment to reflect. What do these reactions and feelings say about your interests? About your character?  The answers to these questions will not necessarily give you a predictive information about whether or not you will do well in a full-time programming course. However, we believe these questions are vital to address for you to be happy and successful in life, including the time you might spend coding at an immersion course.

## Learning From Those Who Went Before Us: Admissions

In finding out more about how you get in, it would be wise to talk to two groups of people. They are:

1. People who got in (we will share insights from those folks!)
2. People who review the application and do the interviews (we will share their insights, too!)

In this section, we will focus on those who are on the admissions sides of the programming courses. We have stories from the students in another chapter.  

We asked Michael Kaiser-Nyman, founder of a programming course called Epicodus (Portland, Oregon formerly in Sacramento, California). Michael noted the following:

> I can't speak for any other coding school, but the two things I look for in Epicodus applicants. First, they should have tried programming before, so that they know that they like it. Second, they should be a good team player.
>

Sean Daken, founder of [RefactorU](http://refactoru.com/) looks for people with high general intelligence + emotional intelligence + professionalism. 

> We want people who are passionate about the path they are pursuing, who have a sense of urgency, and who have maturity in spades.  Successful applicants need be able to communicate very well, be driven and willing to work hard, and be able to learn and apply new concepts quickly.  Basically, were looking at applicants through the lens of a hiring manager - smart, driven, passionate, very strong communicator, etc.  We actually score applicants quantitatively and qualitatively based on perceived raw general intelligence, communication skills, professionalism, passion, how much they have invested up to the point of the application in learning on their own, etc.  We determine the score based on a combination of their application responses, interviews, and in some cases reference checks.
>
> It helps to have some prior coding experience, but not absolutely required.  It is important that people have tried to learn something related to programming on their own, not so much for what that is in particular but that it shows that they have taken initiative and are serious.  The best candidates have all of the qualities I mentioned above AND have tried to learn as much as possible on their own.  They know what they want and know that RefactorU is the most efficient path to getting them there.
>

Shawn Drost, a co-founder San Francisco-based [Hack Reactor](http://hackreactor.com/) lists the following key attributes during the admissions process:

>* __Drive__ - We want to work with people that will push themselves and their peers to surprising amounts of success.
* __Warmth__ - The school ends up being like a family, and my cofounders and I go to crazy lengths for our students that don't make any sense from a business perspective.  Life is too short to spend time with assholes, even when they're all-stars by other metrics.
* __Effectiveness__ - It turns out that getting things done is a unique skillset that carries over between careers/environments.  We like effective people -- those skills apply just as well to software engineering.
* __Intellect__ - Raw horsepower also matters.
* __Technical Chops__ - Many intelligent people will never become software engineers, either because they don't actually have a deep interest in the field or because it just doesn't align with their mindset.  We ensure that applicants have learned the first 10% on their own, mostly so that we know for sure that they can clear those hurdles.
>

## Location, Location, Location?

You might be wondering, does geography matter at all? Jeff Casimir, principal at Jumpstart Labs responded. Asked what the advantages of attending a programming course in San Francisco Bay Aarea might be:

> I'm obviously biased, but will give you a quick answer anyways:
>
>Not being in the SF ecosystem has plusses and minuses. On the downside, if you're in SF, you're a little minnow in a giant pool. Your cost of living during the program is super high. People probably haven't heard of the program you're in.
>
>On the other hand, they're craving developers. You can't turn around in the coffee shop without bumping into someone hiring. You can easily interview in person rather than scheduling trips or doing it over Skype.
>
>Being anywhere EXCEPT SF has minuses, too. Here in Denver there are dozens of jobs, not hundreds. Being here you're not totally immersed in the tech culture -- people are more likely to talk about mountain biking than slinging code.
>
>On the upside, there are way more job here than our students will fill up. I expect about 12 of our 23 students to stay in Colorado. You're a small fish in a small pond -- people have heard of our program, they've been to our office -- essentially our program is the most interesting thing going on in Denver tech. Outside of Colorado, people are coming from SF, Seattle, Portland, NYC, etc to interview and (hopefully) hire our students.
>
>Long story short: I don't think it matters. Pick a program that fits you and has people you like, the job part is easy.
>

It is an interesting insight, but we actually think location matters quite a lot. Certainly, it matters from a personal point of view - you should be where you are happy. But, of course we will focus on the professional impact. Many attend programming courses with the intent of finding a job in software. Geography matters because location (e.g. San Francisco) directly impacts 1) quantity of jobs, 2) quality of jobs, 3) compensation potential, 4) community of like-minded peers, and 5) density of industry experts from whom you can learn more. Clearly, each one of these factors are very important, not to mention combinations of them.

Since both of us live in the San Francisco Bay Area, we are quite biased in thinking that this is one of the best places you could come to attend a full time programming course.

## About Changing Trends

While technology allows us to keep the content current relatively easily, it is important to note that nearly nothing in life is constant. This is true of programming academies.  The curriculum constantly evolves, the applicant pools and admissions criteria compositions change. Even the employer needs for technical talent grows and wanes.

One of us was an early applicant to a San Francisco-based programming course (was admitted, but decided not to attend). Looking at the increasing difficulty in application coding challenges, and the rising caliber of applicants to various local programs has been surprising to many. One might derive some guiding principles from this observation:

1. If you have resolved your doubts about attending, there is value to applying early. Either the competition will be thinner now (than they will be later), or you will have a chance to measure yourself sooner and update your skills accordingly.

2. If your ultimate dream is not to work as a software engineer, then you may want to have a gut check, that you are not chasing a trend. What is cool or in demand today may not be cool or in demand tomorrow.