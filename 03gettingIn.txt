# Getting In

## A Quick Exercise

Write a function to compute factorial of a given number, _n_. 

A factorial is a product of all positive integers from 1 to a given number, _n_. For example, 5 factorial (written as 5!) is 5*4*3*2*1 = 120. If you were sitting next to someone who knew very little about programming, how would you begin to outline what you are trying to do? How would you outline the structure of your code?

Many beginning programmers write a [recursive](http://en.wikipedia.org/wiki/Recursion) solution to this coding challenge. That would work fine to compute 5! or 10! How well does it work for 100! or 1000!?

So, now what? If a recursive solution doesn't quite work, because of the computing time, how would you restructure your code?  Is there a way to compute the multiplication non-recursively from 1 to _n_? And how does that improve performance? Could you refactor your code further to take advantage of a technique called [__memoization__](http://en.wikipedia.org/wiki/Memoization)?

Did you enjoy trying to figure this problem out? Would you enjoy doing so with someone else next to you? Does the process of optimizing your code and make it compute faster appeal to you?

### More Exercises

If you either 1) didn't have enough background to successfuly attempt writing a factorial function, or 2) enjoyed the exercise and want more, might we suggest the following resources?

If former - i.e. you need more basics - try this [Ruby in 100 Minutes Tutorial](http://tutorials.jumpstartlab.com/projects/ruby_in_100_minutes.html) by [JumpstartLab](http://jumpstartlab.com). If latter - i.e. Factorials exercise was a breeze - try your hand at some more challenging algorithms using language of your choice by browsing [Project Euler](http://projecteuler.net/) exercises.

## Learning From Those Who Went Before Us

In finding out more about how you get in, it would be wise to talk to two groups of people. They are:

1. People who got in (we will share insights from those folks!)
2. People who review the application and do the interviews (we will share their insights, too!)

In this section, we will focus on those who are on the admissions sides of the programming courses. We have stories from the students in another chapter.  

## Chief Admissions Criteria

We asked Michael Kaiser-Nyman, founder of a programming course called Epicodus (Portland, Oregon formerly in Sacramento, California). Michael noted the following:

> I can't speak for any other coding school, but the two things I look for in Epicodus applicants. First, they should have tried programming before, so that they know that they like it. Second, they should be a good team player.
>

Sean Daken, founder of [RefactorU](http://refactoru.com/) looks for people with high general intelligence + emotional intelligence + professionalism. 

> We want people who are passionate about the path they are pursuing, who have a sense of urgency, and who have maturity in spades.  Successful applicants need be able to communicate very well, be driven and willing to work hard, and be able to learn and apply new concepts quickly.  Basically, were looking at applicants through the lens of a hiring manager - smart, driven, passionate, very strong communicator, etc.  We actually score applicants quantitatively and qualitatively based on perceived raw general intelligence, communication skills, professionalism, passion, how much they have invested up to the point of the application in learning on their own, etc.  We determine the score based on a combination of their application responses, interviews, and in some cases reference checks.

> It helps to have some prior coding experience, but not absolutely required.  It is important that people have tried to learn something related to programming on their own, not so much for what that is in particular but that it shows that they have taken initiative and are serious.  The best candidates have all of the qualities I mentioned above AND have tried to learn as much as possible on their own.  They know what they want and know that RefactorU is the most efficient path to getting them there.
>

Shawn Drost, a co-founder San Francisco-based [Hack Reactor](http://hackreactor.com/) lists the following key attributes during the admissions process:

> * Drive - We want to work with people that will push themselves and their peers to surprising amounts of success.
* Warmth - The school ends up being like a family, and my cofounders and I go to crazy lengths for our students that don't make any sense from a business perspective.  Life is too short to spend time with assholes, even when they're all-stars by other metrics.
* Effectiveness - It turns out that getting things done is a unique skillset that carries over between careers/environments.  We like effective people -- those skills apply just as well to software engineering.
* Intellect - Raw horsepower also matters.
* Technical Chops - Many intelligent people will never become software engineers, either because they don't actually have a deep interest in the field or because it just doesn't align with their mindset.  We ensure that applicants have learned the first 10% on their own, mostly so that we know for sure that they can clear those hurdles.
>

Contribute additional insights through this [Quora entry about admissions critera](http://www.quora.com/Programming-Bootcamps/What-are-the-chief-admission-criteria-for-those-admitted-to-programming-schools).

## About Changing Trends

While technology allows us to keep the content current relatively easily, it is important to note that nearly nothing in life is constant. This is true of programming academies.  The curriculum constantly evolves, the applicant pools and admissions criteria compositions change. Even the employer needs for technical talent grows and wanes.

One of us was an early applicant to a San Francisco-based programming course (was admitted, but decided not to attend). Looking at the increasing difficulty in application coding challenges, and the rising caliber of applicants to various local programs has been surprising to many. One might derive some guiding principles from this observation:

1. If you have resolved your doubts about attending, there is value to applying early. Either the competition will be thinner now (than they will be later), or you will have a chance to measure yourself sooner and update your skills accordingly.

2. If your ultimate dream is not to work as a software engineer, then you may want to have a gut check, that you are not chasing a trend. What is cool or in demand today may not be cool or in demand tomorrow.